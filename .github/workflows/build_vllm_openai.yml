name: Build vLLM Container and Push to Docker Hub

on:
  workflow_dispatch:
    inputs:
      vllm_tag:
        description: "vLLM upstream image tag (e.g., v0.9.2; leave empty to use Dockerfile ARG default value, i.e. latest)"
        required: false
        type: string
      cuda_suffix:
        description: "CUDA suffix of framework_version"
        required: false
        default: "CUDA"
        type: string
      container_name:
        description: "Container name for signing/scanning"
        required: false
        default: "vllm-openai"
        type: string
      register_baseline:
        description: "Register baseline to API (true/false)"
        required: false
        default: false
        type: boolean


permissions:
  contents: read

env:
  PLATFORM_OS: linux
  ARCH: amd64
  DOCKERFILE: Dockerfile
  IMAGE_NAME: vllm-openai

jobs:
  build-sign-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Free Disk Space (fast)
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: true
          dotnet: true
          large-packages: true
          docker-images: false

      - name: Install jq (for parsing GitHub API)
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends jq ca-certificates

      - name: Download wheels (safetensors + cryptotensors linux x86_64)
        id: dl_wheels
        env:
          GH_OWNER: koalavault
          GH_REPO: cryptotensors
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}
        run: |
          set -euo pipefail
          auth=(-H "Authorization: Bearer ${GH_TOKEN}" -H "Accept: application/vnd.github+json")
      
          echo "[info] GET releases list" >&2
          JSON=$(curl -fsSL "${auth[@]}" "https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/releases?per_page=100")
      
          ASSETS=$(printf '%s' "$JSON" | jq -c '
            [ .[] | {tag:.tag_name, draft, prerelease, assets:(.assets // [])} ]
            | map(.assets[]? as $a | {tag, draft, prerelease} + {id:$a.id, name:$a.name, created_at:$a.created_at})
          ')
          [[ "$ASSETS" != "[]" && -n "$ASSETS" ]] || { echo "::error::No assets visible."; exit 1; }
      
          # safetensors: safetensors-*.whl
          SAFE_LINE=$(printf '%s' "$ASSETS" | jq -r '
            .[] 
            | select(.name|test("^safetensors-.*\\.whl$"; "i"))
            | {name, id, created_at, 
                v: ((.name | capture("^safetensors-(?<v>[0-9][0-9\\.]*)")).v // "")}
            | [.name, .v, (.id|tostring), .created_at] | @tsv
          ' | sort -t$'\t' -k2,2V -k4,4 | tail -n1)
          [[ -n "${SAFE_LINE}" ]] || { echo "::error::No safetensors wheel found."; exit 1; }
          SAFE_NAME=$(cut -f1 <<<"$SAFE_LINE"); SAFE_ID=$(cut -f3 <<<"$SAFE_LINE")
      
          # cryptotensors: cryptotensors + linux + x86_64 + .whl
          CRYPTO_LINE=$(printf '%s' "$ASSETS" | jq -r '
            .[] 
            | select(.name|test("cryptotensors"; "i")) 
            | select(.name|test("linux"; "i")) 
            | select(.name|test("x86_64"; "i")) 
            | select(.name|test("\\.whl$"; "i"))
            | {name, id, created_at,
                v: ((.name | capture("^cryptotensors-(?<v>[0-9][0-9\\.]*)")).v // "")}
            | [.name, .v, (.id|tostring), .created_at] | @tsv
          ' | sort -t$'\t' -k2,2V -k4,4 | tail -n1)
          [[ -n "${CRYPTO_LINE}" ]] || { echo "::error::No cryptotensors linux x86_64 wheel found."; exit 1; }
          CRYPTO_NAME=$(cut -f1 <<<"$CRYPTO_LINE"); CRYPTO_ID=$(cut -f3 <<<"$CRYPTO_LINE")
      
          download_asset () {
            local ID="${1:?missing asset id}"
            local OUT="${2:?missing output filename}"
            local URL="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/releases/assets/${ID}"
            echo "[info] Downloading ${OUT} via ${URL}" >&2
            curl -fsSLL \
              -H "Authorization: Bearer ${GH_TOKEN}" \
              -H "Accept: application/octet-stream" \
              -o "${OUT}" \
              "${URL}"
          }
      
          # Download with original file names (canonical wheel names)
          download_asset "${SAFE_ID}"   "${SAFE_NAME}"
          download_asset "${CRYPTO_ID}" "${CRYPTO_NAME}"
      
          # Copy to fixed names for easy reference; original names remain for pip
          cp -f "$SAFE_NAME" safetensors.whl
          cp -f "$CRYPTO_NAME" cryptotensors.whl
      
          # Expose both "fixed-name paths" and "original names" as outputs
          echo "safetensors_path=$PWD/safetensors.whl"     >> "$GITHUB_OUTPUT"
          echo "cryptotensors_path=$PWD/cryptotensors.whl" >> "$GITHUB_OUTPUT"
          echo "safe_wheel=$SAFE_NAME"   >> "$GITHUB_OUTPUT"
          echo "crypto_wheel=$CRYPTO_NAME" >> "$GITHUB_OUTPUT"
      
          sha256sum "$SAFE_NAME" "$CRYPTO_NAME" || true

      - name: Download hash-builder by asset id (private-friendly)
        id: dl_hash_builder
        env:
          GH_OWNER: koalavault
          GH_REPO: cryptotensors
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}   # your PAT
          ASSET_PREFIX: hash-builder-linux-amd64
          RELEASE_TAG: hash-builder                    # since your tag is called hash-builder, lock to it
        run: |
          set -euo pipefail
      
          # 1) Get release exactly by tag
          REL_API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/releases/tags/${RELEASE_TAG}"
          REL_JSON=$(curl -fsSL \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            "$REL_API")
      
          # 2) Find the asset in this release and extract asset id
          ASSET_ID=$(echo "$REL_JSON" | jq -r --arg p "$ASSET_PREFIX" '
            .assets[] | select(.name | startswith($p)) | .id
          ' | head -n1)
      
          if [[ -z "${ASSET_ID}" || "${ASSET_ID}" == "null" ]]; then
            echo "::error::Cannot find asset starting with '${ASSET_PREFIX}' in tag=${RELEASE_TAG}"
            echo "$REL_JSON" | jq '{tag:.tag_name, draft, prerelease, assets:[.assets[]?|{name, id, size, created_at}] }'
            exit 1
          fi
      
          # 3) Use official assets/{id} download endpoint (works for private/cross-repo)
          DL_API="https://api.github.com/repos/${GH_OWNER}/${GH_REPO}/releases/assets/${ASSET_ID}"
          echo "[info] download asset_id=${ASSET_ID} via $DL_API"
          curl -fsSLL \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -H "Accept: application/octet-stream" \
            -o hash-builder \
            "$DL_API"
      
          chmod +x hash-builder
          echo "path=$PWD/hash-builder" >> "$GITHUB_OUTPUT"
          sha256sum hash-builder || true

      - name: Determine vLLM tag & write version.json
        id: meta
        run: |
          set -euo pipefail
          VTAG="${{ github.event.inputs.vllm_tag || '' }}"
          if [[ -z "$VTAG" ]]; then
            VTAG="$(awk -F= '/^ARG[[:space:]]+VLLM_TAG=/{print $2; exit}' "${{ env.DOCKERFILE }}")"
          fi
          VTAG="${VTAG:-latest}"
          echo "vllm_tag=$VTAG" >> "$GITHUB_OUTPUT"

          # Get GitHub commit information
          GITHUB_SHA="${{ github.sha }}"
          GITHUB_REF="${{ github.ref }}"
          GITHUB_REF_NAME="${{ github.ref_name }}"
          GITHUB_REPOSITORY="${{ github.repository }}"
          GITHUB_RUN_ID="${{ github.run_id }}"
          export GITHUB_SHA GITHUB_REF GITHUB_REF_NAME GITHUB_REPOSITORY GITHUB_RUN_ID

          # Get git commit hash (use tag if available, otherwise use commit SHA)
          GIT_COMMIT="${{ github.ref_name }}"
          if [[ "$GIT_COMMIT" == "refs/heads/"* ]]; then
            GIT_COMMIT="${{ github.sha }}"
          fi
          export GIT_COMMIT

          # Build framework version with commit info (prefix with 'KV' for KoalaVault)
          FRAMEWORK_VERSION="vllm-${VTAG}-${{ env.PLATFORM_OS }}-${{ env.ARCH }}-${{ github.event.inputs.cuda_suffix }}-KV${GIT_COMMIT:0:8}"
          export FRAMEWORK_VERSION

          # Get current build date in ISO format
          BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          export BUILD_DATE

          python3 - <<'PY'
          import json, os
          p = "version.json"
          data = {}
          if os.path.exists(p):
              try:
                  with open(p, "r", encoding="utf-8") as f:
                      data = json.load(f)
              except Exception:
                  data = {}
          data["framework_version"] = os.environ.get("FRAMEWORK_VERSION", "")
          data["git_commit"] = os.environ.get("GIT_COMMIT", "")
          data["build_date"] = os.environ.get("BUILD_DATE", "")
          with open(p, "w", encoding="utf-8") as f:
              json.dump(data, f, ensure_ascii=False, indent=2)
          print("== version.json ==")
          print(json.dumps(data, ensure_ascii=False, indent=2))
          PY

      - uses: docker/setup-buildx-action@v3

      - name: Login Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build image
        id: build
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.vllm_tag }}"
          IMAGE_REF="${{ vars.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:${TAG}"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

          # Build with push based on input
          echo "[info] Building and pushing image to Docker Hub"
          docker buildx build \
            --platform "${{ env.PLATFORM_OS }}/${{ env.ARCH }}" \
            --file "${{ env.DOCKERFILE }}" \
            --build-arg "VLLM_TAG=${TAG}" \
            --tag "${IMAGE_REF}" \
            --provenance=false \
            --push \
            .

      - name: Drop build cache (free peak space)
        run: |
          set -euo pipefail
          docker buildx du || true
          docker buildx prune -af
          docker image prune -af || true
          df -h || true

      - name: Pull image for local run
        id: pull
        run: |
          set -euo pipefail
          docker pull "${{ steps.build.outputs.image_ref }}"

      - name: Run container (sleep)
        id: run
        run: |
          set -euo pipefail
          CNAME="${{ github.event.inputs.container_name }}"
          docker rm -f "$CNAME" >/dev/null 2>&1 || true
          docker run -d --name "$CNAME" --entrypoint /bin/sh "${{ steps.build.outputs.image_ref }}" -lc "sleep infinity"
          echo "container_name=$CNAME" >> "$GITHUB_OUTPUT"
          
      - name: Run hash-builder (scan/sign)
        id: hash_builder
        run: |
          set -euo pipefail
          CONTAINER="${{ steps.run.outputs.container_name }}"
          HB="${{ steps.dl_hash_builder.outputs.path }}"
          HB="$(realpath -P "$HB")"
          HB_DIR="$(dirname "$HB")"
          HB_PARENT="$(dirname "$HB_DIR")"

          echo "[debug] run hash-builder: $HB (container=$CONTAINER)"
          CONTAINER="$CONTAINER" "$HB" | tee baseline_hash.txt

          if [[ -f "./register_payload.json" ]]; then
            PAYLOAD="./register_payload.json"
          elif [[ -f "$HB_DIR/register_payload.json" ]]; then
            PAYLOAD="$HB_DIR/register_payload.json"
          elif [[ -f "$HB_PARENT/register_payload.json" ]]; then
            PAYLOAD="$HB_PARENT/register_payload.json"
          else
            echo "::error::register_payload.json not found in ./ or $HB_DIR or $HB_PARENT"
            exit 1
          fi

          MEAS_HASH="$(jq -r '.measurement_hash // .root_sha256 // empty' "$PAYLOAD")"
          [[ -z "$MEAS_HASH" ]] && { echo "::error::measurement_hash missing in $PAYLOAD"; exit 1; }

          echo "measurement_hash=$MEAS_HASH" >> "$GITHUB_OUTPUT"
          echo "[info] Extracted measurement_hash: $MEAS_HASH from $PAYLOAD"



      - name: Print baseline information
        run: |
          set -euo pipefail
          echo "[info] === Baseline Information ==="
          
          
          # Get framework version from version.json
          FRAMEWORK_VERSION=$(jq -r '.framework_version' version.json)
          if [[ -z "$FRAMEWORK_VERSION" || "$FRAMEWORK_VERSION" == "null" ]]; then
            echo "::error::Could not get framework_version from version.json"
            exit 1
          fi
          
          # Get root_sha256 from hash_builder step output
          ROOT_SHA256="${{ steps.hash_builder.outputs.measurement_hash }}"
          
          echo "[info] Framework Version: $FRAMEWORK_VERSION"
          echo "[info] Baseline Hash: $ROOT_SHA256"
          echo "[info] Framework Type: vllm-openai"
          echo "[info] ================================"

      - name: Register baseline to API
        if: ${{ github.event.inputs.register_baseline == 'true' && vars.KOALAVAULT_API_BASE_URL != '' }}
        run: |
          set -euo pipefail
          if [[ -z "${{ secrets.KOALAVAULT_ADMIN_API_KEY }}" ]]; then
            echo "::error::KOALAVAULT_ADMIN_API_KEY secret is not set"
            exit 1
          fi
          echo "[info] Registering baseline to API..."
          
          # Use root_sha256 from hash_builder step output as baseline_hash
          BASELINE_HASH="${{ steps.hash_builder.outputs.measurement_hash }}"
          if [[ -z "$BASELINE_HASH" || "$BASELINE_HASH" == "null" ]]; then
            echo "::error::Could not get root_sha256 from hash_builder step"
            exit 1
          fi
          
          # Get framework version from version.json
          FRAMEWORK_VERSION=$(jq -r '.framework_version' version.json)
          if [[ -z "$FRAMEWORK_VERSION" || "$FRAMEWORK_VERSION" == "null" ]]; then
            echo "::error::Could not get framework_version from version.json"
            exit 1
          fi
          
          # Prepare baseline data
          BASELINE_DATA=$(cat <<EOF
          {
            "framework_version": "$FRAMEWORK_VERSION",
            "framework_type": "vllm-openai",
            "baseline_hash": "$BASELINE_HASH",
            "description": "vLLM framework baseline version $FRAMEWORK_VERSION",
            "tag": "stable"
          }
          EOF
          )
          
          echo "[info] Registering baseline: $FRAMEWORK_VERSION with hash: $BASELINE_HASH"
          
          # Register baseline
          RESPONSE=$(curl -s -X POST "${{ vars.KOALAVAULT_API_BASE_URL }}/api/admin/framework/baselines" \
            -H "Authorization: Bearer ${{ secrets.KOALAVAULT_ADMIN_API_KEY }}" \
            -H "Content-Type: application/json" \
            -d "$BASELINE_DATA")
          
          # Check response
          if echo "$RESPONSE" | jq -e '.success' > /dev/null; then
            BASELINE_ID=$(echo "$RESPONSE" | jq -r '.data.id')
            echo "[info] Baseline registered successfully with ID: $BASELINE_ID"
            echo "[info] Note: Baseline is registered but not activated. Please activate manually if needed."
          else
            echo "::error::Failed to register baseline"
            echo "$RESPONSE"
            exit 1
          fi
