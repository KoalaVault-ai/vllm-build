name: Build and Release vLLM Container

on:
  push:
    tags:
      - 'v[0-9]+.[0-9]+.[0-9]+'
      - 'v[0-9]+.[0-9]+.[0-9]+-rc.[0-9]+'
  workflow_dispatch:
    inputs:
      vllm_version:
        description: "vLLM version (e.g., v0.9.2), leave empty to use vllm_versions file"
        required: false
        type: string
      architecture:
        description: "Architecture to build"
        required: false
        default: "both"
        type: choice
        options:
          - both
          - amd64
          - arm64
      register_baseline:
        description: "Register baseline to API"
        required: false
        default: false
        type: boolean
permissions:
  contents: read
  packages: write

env:
  DOCKERFILE: Dockerfile
  GHCR_IMAGE_REPO: ghcr.io/koalavault-ai/vllm-openai
  DOCKERHUB_IMAGE_REPO: ${{ vars.DOCKERHUB_USERNAME }}/vllm-openai

jobs:
  prepare:
    name: Prepare Build Matrix
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.set-matrix.outputs.matrix }}
      architecture_choice: ${{ steps.set-matrix.outputs.architecture_choice }}
    steps:
      - name: Determine build matrix based on architecture selection
        id: set-matrix
        run: |
          ARCH_CHOICE="${{ github.event.inputs.architecture }}"
          
          # Tag push always builds both
          if [ "${{ github.event_name }}" = "push" ]; then
            ARCH_CHOICE="both"
          elif [ -z "$ARCH_CHOICE" ]; then
            ARCH_CHOICE="both"
          fi
          
          echo "architecture_choice=$ARCH_CHOICE" >> "$GITHUB_OUTPUT"
          echo "Selected architecture: $ARCH_CHOICE"
          
          # Generate matrix JSON
          if [ "$ARCH_CHOICE" = "amd64" ]; then
            echo 'matrix={"arch":["x86"]}' >> "$GITHUB_OUTPUT"
            echo "Building: amd64 only"
          elif [ "$ARCH_CHOICE" = "arm64" ]; then
            echo 'matrix={"arch":["aarch64"]}' >> "$GITHUB_OUTPUT"
            echo "Building: arm64 only"
          else
            echo 'matrix={"arch":["x86","aarch64"]}' >> "$GITHUB_OUTPUT"
            echo "Building: both amd64 and arm64"
          fi

  build-and-push:
    name: Build vLLM OpenAI (${{ matrix.arch }})
    needs: prepare
    runs-on: ubuntu-latest
    outputs:
      build_mode: ${{ steps.trigger.outputs.build_mode }}
      dryrun: ${{ steps.trigger.outputs.dryrun }}
      vllm_version: ${{ steps.meta.outputs.vllm_version }}
      vllm_build_version_full: ${{ steps.vllm_build_ver.outputs.vllm_build_version_full }}
      ct_version_full: ${{ steps.ct_tag.outputs.ct_version_full }}
      ct_version_wheel: ${{ steps.ct_tag.outputs.ct_version_wheel }}
      architecture_choice: ${{ needs.prepare.outputs.architecture_choice }}
      image_ref: ${{ steps.build.outputs.image_ref }}
      register_baseline: ${{ steps.trigger.outputs.register_baseline }}
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - name: Determine trigger mode
        id: trigger
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Tag push trigger
            TAG_NAME="${{ github.ref_name }}"
            echo "Triggered by tag: $TAG_NAME"
            
            # Determine build mode based on tag format
            if [[ "$TAG_NAME" =~ -rc\. ]]; then
              BUILD_MODE="rc"
              echo "RC tag detected, using RC mode"
            else
              BUILD_MODE="release"
              echo "Release tag detected, using release mode"
            fi
            
            DRYRUN="false"
            REGISTER_BASELINE="true"
          else
            # Manual workflow_dispatch trigger - always RC mode
            BUILD_MODE="rc"
            DRYRUN="false"
            REGISTER_BASELINE="${{ github.event.inputs.register_baseline }}"
            echo "Manual trigger - using RC mode"
          fi
          
          echo "build_mode=$BUILD_MODE" >> "$GITHUB_OUTPUT"
          echo "dryrun=$DRYRUN" >> "$GITHUB_OUTPUT"
          echo "register_baseline=$REGISTER_BASELINE" >> "$GITHUB_OUTPUT"
          
          echo "=== Trigger Configuration ==="
          echo "Build Mode: $BUILD_MODE"
          echo "Dry Run: $DRYRUN"
          echo "Register Baseline: $REGISTER_BASELINE"
      
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Determine vLLM version from tag message or input
        id: vllm_version
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Tag push: try to get vLLM version from tag message
            TAG_NAME="${{ github.ref_name }}"
            TAG_MESSAGE=$(git tag -l --format='%(contents)' "$TAG_NAME" 2>/dev/null || echo "")
            
            if [[ "$TAG_MESSAGE" =~ vllm:\ *(v[0-9]+\.[0-9]+\.[0-9]+) ]]; then
              VLLM_VERSION="${BASH_REMATCH[1]}"
              echo "vLLM version from tag message: $VLLM_VERSION"
            else
              echo "No vLLM version in tag message, will use vllm_versions file"
              VLLM_VERSION=""
            fi
          else
            # Manual trigger: use input
            VLLM_VERSION="${{ github.event.inputs.vllm_version }}"
            if [ -n "$VLLM_VERSION" ]; then
              echo "vLLM version from input: $VLLM_VERSION"
            else
              echo "No vLLM version in input, will use vllm_versions file"
            fi
          fi
          
          # If still empty, read from vllm_versions file
          if [ -z "$VLLM_VERSION" ]; then
            VLLM_VERSION=$(grep -v '^#' vllm_versions | grep -v '^$' | head -1 | tr -d '[:space:]')
            if [ -z "$VLLM_VERSION" ]; then
              echo "::error::No vLLM version found in vllm_versions file"
              exit 1
            fi
            echo "Using vLLM version from vllm_versions file: $VLLM_VERSION"
          fi
          
          echo "vllm_version=$VLLM_VERSION" >> "$GITHUB_OUTPUT"
          echo "Final vLLM version: $VLLM_VERSION"

      - name: Free disk space
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: false

      - name: Determine vLLM-Build version
        id: vllm_build_ver
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            # Tag trigger: use the tag directly as vllm-build version
            VLLM_BUILD_VERSION="${{ github.ref_name }}"
            echo "Using tag as vllm-build version: $VLLM_BUILD_VERSION"
          else
            # Manual trigger: auto-calculate next RC version
            git fetch --tags
            LATEST_TAG=$(git tag -l 'v*' | sort -V | tail -1)
            
            if [ -z "$LATEST_TAG" ]; then
              # No tags exist, start with v0.0.1-rc.1
              BASE_VERSION="0.0.1"
              RC_NUM=1
            else
              # Remove 'v' prefix
              LATEST_VERSION="${LATEST_TAG#v}"
              
              if [[ "$LATEST_VERSION" =~ ^([0-9]+\.[0-9]+\.[0-9]+)-rc\.([0-9]+)$ ]]; then
                # Latest is an RC version, increment RC number
                BASE_VERSION="${BASH_REMATCH[1]}"
                RC_NUM=$((${BASH_REMATCH[2]} + 1))
              else
                # Latest is a release version, increment patch and start rc.1
                if [[ "$LATEST_VERSION" =~ ^([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
                  MAJOR="${BASH_REMATCH[1]}"
                  MINOR="${BASH_REMATCH[2]}"
                  PATCH="${BASH_REMATCH[3]}"
                  BASE_VERSION="${MAJOR}.${MINOR}.$((PATCH + 1))"
                  RC_NUM=1
                else
                  echo "::error::Failed to parse version: $LATEST_VERSION"
                  exit 1
                fi
              fi
            fi
            
            VLLM_BUILD_VERSION="v${BASE_VERSION}-rc.${RC_NUM}"
            echo "Auto-calculated RC version for manual trigger: $VLLM_BUILD_VERSION"
          fi
          
          echo "vllm_build_version_full=$VLLM_BUILD_VERSION" >> "$GITHUB_OUTPUT"

      - name: Determine CryptoTensors release tag
        id: ct_tag
        env:
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}
        run: |
          BUILD_MODE="${{ steps.trigger.outputs.build_mode }}"
          if [ "$BUILD_MODE" = "rc" ]; then
            TAG=$(gh release view --repo KoalaVault-ai/cryptotensors --json tagName -q .tagName)
          else
            TAG=$(gh release list --repo KoalaVault-ai/cryptotensors --limit 50 | grep -v 'rc\.' | head -1 | awk '{print $1}')
          fi
          echo "cryptotensors_tag=$TAG" >> "$GITHUB_OUTPUT"
          CT_VER="${TAG#core/}"
          echo "ct_version_full=$CT_VER" >> "$GITHUB_OUTPUT"

      - name: Download cryptotensors packages by tag
        env:
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}
        run: |
          TAG="${{ steps.ct_tag.outputs.cryptotensors_tag }}"
          
          # Map architecture to wheel architecture
          ARCH="${{ matrix.arch }}"
          if [ "$ARCH" = "x86" ]; then
            WHEEL_ARCH="x86_64"
          elif [ "$ARCH" = "aarch64" ]; then
            WHEEL_ARCH="aarch64"
          else
            echo "::error::Unsupported architecture: $ARCH"
            exit 1
          fi
          
          echo "Downloading by tag: $TAG for arch: $WHEEL_ARCH"
          
          # Clean up any existing wheel files first
          rm -f *.whl 2>/dev/null || true
          
          gh release download "$TAG" --repo KoalaVault-ai/cryptotensors --pattern "*manylinux*${WHEEL_ARCH}.whl"
          gh release download "$TAG" --repo KoalaVault-ai/cryptotensors --pattern "safetensors-*.whl"
          
          # Verify required files exist
          if ! ls cryptotensors-*-manylinux_*_${WHEEL_ARCH}.whl 1> /dev/null 2>&1; then
            echo "::error::cryptotensors wheel for $WHEEL_ARCH not found"
            echo "Available files:"
            ls -la *.whl 2>/dev/null || echo "No wheel files found"
            exit 1
          fi
          
          if ! ls safetensors-*.whl 1> /dev/null 2>&1; then
            echo "::error::safetensors wheel not found"
            exit 1
          fi
          
          echo "Downloaded packages:"
          ls -lh *.whl

      

      - name: Extract CryptoTensors version
        id: crypto_version
        run: |
          # Extract version from cryptotensors wheel filename (PEP 440 format)
          # e.g., cryptotensors-0.1.0rc1-cp38-abi3-manylinux_2_28_x86_64.whl -> 0.1.0rc1
          # e.g., cryptotensors-0.1.0-cp38-abi3-manylinux_2_28_x86_64.whl -> 0.1.0
          CRYPTO_WHL=$(ls cryptotensors-*-manylinux_*.whl | head -1)
          CRYPTO_VERSION_WHEEL=$(echo "$CRYPTO_WHL" | sed 's/cryptotensors-//' | sed 's/-cp.*//')
          CRYPTO_VERSION_CLEAN=$(echo "$CRYPTO_VERSION_WHEEL" | sed 's/rc/rc/')
          echo "ct_version_wheel=$CRYPTO_VERSION_WHEEL" >> "$GITHUB_OUTPUT"
          echo "ct_version_clean=$CRYPTO_VERSION_CLEAN" >> "$GITHUB_OUTPUT"
          echo "ct_version_full=${{ steps.ct_tag.outputs.ct_version_full }}" >> "$GITHUB_OUTPUT"
          echo "CryptoTensors wheel version: $CRYPTO_VERSION_WHEEL"
          echo "CryptoTensors wheel: $CRYPTO_WHL"

      - name: Determine build metadata
        id: meta
        run: |
          set -euo pipefail
          
          # Build base image from version input and architecture
          VLLM_VERSION="${{ steps.vllm_version.outputs.vllm_version }}"
          ARCH="${{ matrix.arch }}"
          
          # Map architecture to Docker platform
          if [ "$ARCH" = "x86" ]; then
            DOCKER_ARCH="amd64"
          elif [ "$ARCH" = "aarch64" ]; then
            DOCKER_ARCH="arm64"
          else
            DOCKER_ARCH="$ARCH"
          fi
          
          # vLLM official images support both amd64 and arm64
          BASE_IMAGE="vllm/vllm-openai:${VLLM_VERSION}"
          IMAGE_NAME="vllm-openai"
          
          echo "base_image=$BASE_IMAGE" >> "$GITHUB_OUTPUT"
          echo "image_name=$IMAGE_NAME" >> "$GITHUB_OUTPUT"
          echo "vllm_version=$VLLM_VERSION" >> "$GITHUB_OUTPUT"
          
          PLATFORM_OS="linux"
          
          echo "platform_os=$PLATFORM_OS" >> "$GITHUB_OUTPUT"
          echo "arch=$ARCH" >> "$GITHUB_OUTPUT"
          echo "docker_arch=$DOCKER_ARCH" >> "$GITHUB_OUTPUT"

          # Get CryptoTensors version
          CT_VERSION_WHEEL="${{ steps.crypto_version.outputs.ct_version_wheel }}"
          CT_VERSION_CLEAN="${{ steps.crypto_version.outputs.ct_version_clean }}"
          CT_VERSION_FULL="${{ steps.ct_tag.outputs.ct_version_full }}"
          echo "ct_version_wheel=$CT_VERSION_WHEEL" >> "$GITHUB_OUTPUT"
          echo "ct_version_clean=$CT_VERSION_CLEAN" >> "$GITHUB_OUTPUT"
          echo "ct_version_full=$CT_VERSION_FULL" >> "$GITHUB_OUTPUT"
          
          # Get vllm-build version
          VLLM_BUILD_VERSION="${{ steps.vllm_build_ver.outputs.vllm_build_version_full }}"
          echo "vllm_build_version_full=$VLLM_BUILD_VERSION" >> "$GITHUB_OUTPUT"

          # Platform is always CUDA for vllm-openai
          PLATFORM_SUFFIX="cuda"
          
          # Build framework version: vllm-{version}-{arch}-{cuda}-{os}-build-{vllm-build-ver}-cryptotensors-{crypto-ver}
          FRAMEWORK_VERSION="vllm-${VLLM_VERSION}-${ARCH}-${PLATFORM_SUFFIX}-${PLATFORM_OS}-build-${VLLM_BUILD_VERSION}-cryptotensors-${{ steps.ct_tag.outputs.ct_version_full }}"
          echo "framework_version=$FRAMEWORK_VERSION" >> "$GITHUB_OUTPUT"

          # Get current build date (YYYY-MM-DD format)
          BUILD_DATE=$(date -u +"%Y-%m-%d")
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"

          echo "=== Build Metadata ==="
          echo "Base Image: $BASE_IMAGE"
          echo "Image Name: $IMAGE_NAME"
          echo "Arch: $ARCH"
          echo "Docker Arch: $DOCKER_ARCH"
          echo "Platform: $PLATFORM_SUFFIX"
          echo "OS: $PLATFORM_OS"
          echo "vLLM Version: $VLLM_VERSION"
          echo "vLLM-Build Version: $VLLM_BUILD_VERSION"
          echo "CryptoTensors Version: $CT_VERSION_FULL"
          echo "Framework Version: $FRAMEWORK_VERSION"
          echo "Build Date: $BUILD_DATE"

      - name: Set up QEMU for ARM64 emulation
        if: matrix.arch == 'aarch64'
        uses: docker/setup-qemu-action@v3
        with:
          platforms: linux/arm64

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest

      - name: Login GHCR
        if: ${{ steps.trigger.outputs.dryrun != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pre-pull cleanup to maximize space
        run: |
          echo "=== Disk space before cleanup ==="
          df -h
          docker system df
          
          # Remove all stopped containers
          docker container prune -f
          # Remove all unused images
          docker image prune -a -f
          # Remove all unused networks
          docker network prune -f
          # Remove all build cache
          docker builder prune -a -f
          # System-level cleanup
          docker system prune -a -f --volumes
          
          echo "=== Disk space after cleanup ==="
          df -h
          docker system df

      - name: Pull vLLM base image for target architecture
        run: |
          BASE_IMAGE="${{ steps.meta.outputs.base_image }}"
          PLATFORM="${{ steps.meta.outputs.platform_os }}/${{ steps.meta.outputs.docker_arch }}"
          
          echo "Pulling base image for platform: ${PLATFORM}"
          docker pull --platform "${PLATFORM}" "${BASE_IMAGE}"
          
          echo "Verifying pulled image architecture:"
          docker image inspect "${BASE_IMAGE}" --format '{{.Architecture}}'
          
          # Clean up all images except the just-pulled base image
          echo "Cleaning up other images to free space..."
          docker images --format "{{.Repository}}:{{.Tag}}" | grep -v "${BASE_IMAGE}" | xargs -r docker rmi -f || true
          docker system prune -a -f
          
          echo "Disk space after base image pull and cleanup:"
          df -h

      - name: Build application image to GHCR
        id: build
        run: |
          set -euo pipefail
          VLLM_VERSION="${{ steps.meta.outputs.vllm_version }}"
          VLLM_BUILD_VERSION="${{ steps.vllm_build_ver.outputs.vllm_build_version_full }}"
          CT_VERSION="${{ steps.ct_tag.outputs.ct_version_full }}"
          PLATFORM="${{ steps.meta.outputs.platform_os }}/${{ steps.meta.outputs.docker_arch }}"
          
          # Convert versions to PEP 440 format (remove hyphens before rc)
          # v0.0.3-rc.1 -> v0.0.3rc1
          VLLM_VERSION_TAG=$(echo "$VLLM_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          VLLM_BUILD_VERSION_TAG=$(echo "$VLLM_BUILD_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          CT_VERSION_TAG=$(echo "$CT_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          
          # Primary tag uses PEP 440 format
          PRIMARY_TAG="vllm-${VLLM_VERSION_TAG}_build-${VLLM_BUILD_VERSION_TAG}_crypto-${CT_VERSION_TAG}"
          # Per-arch tag suffix
          if [ "${{ steps.meta.outputs.docker_arch }}" = "amd64" ]; then
            ARCH_SUFFIX="amd64"
          else
            ARCH_SUFFIX="arm64"
          fi
          IMAGE_REF_GHCR="${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}-${ARCH_SUFFIX}"
          DRYRUN="${{ steps.trigger.outputs.dryrun }}"
          
          echo "image_ref=${IMAGE_REF_GHCR}" >> "$GITHUB_OUTPUT"

          echo "Building from base image: ${{ steps.meta.outputs.base_image }}"
          echo "Target image: ${IMAGE_REF_GHCR}"
          echo "Platform: ${PLATFORM}"
          echo "Architecture: ${{ steps.meta.outputs.arch }}"
          
          if [ "$DRYRUN" = "true" ]; then
            echo "Mode: DRY RUN (build only, no push)"
            docker buildx build \
              --builder default \
              --platform "${PLATFORM}" \
              --file "${{ env.DOCKERFILE }}" \
              --build-arg "BASE_IMAGE=${{ steps.meta.outputs.base_image }}" \
              --build-arg "FRAMEWORK_VERSION=${{ steps.meta.outputs.framework_version }}" \
              --build-arg "VLLM_VERSION=${{ steps.meta.outputs.vllm_version }}" \
              --build-arg "VLLM_BUILD_VERSION=${{ steps.vllm_build_ver.outputs.vllm_build_version_full }}" \
              --build-arg "CRYPTOTENSORS_VERSION=${{ steps.crypto_version.outputs.ct_version_full }}" \
              --build-arg "BUILD_DATE=${{ steps.meta.outputs.build_date }}" \
              --label "io.vllm.version=${VLLM_VERSION}" \
              --label "io.vllm.build=${VLLM_BUILD_VERSION}" \
              --label "io.cryptotensors.version=${CT_VERSION}" \
              --label "org.opencontainers.image.version=${PRIMARY_TAG}" \
              --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
              --tag "${IMAGE_REF_GHCR}" \
              --provenance=false \
              --load \
              .
          else
            echo "Mode: RELEASE (build and push)"
            docker buildx build \
              --builder default \
              --platform "${PLATFORM}" \
              --file "${{ env.DOCKERFILE }}" \
              --build-arg "BASE_IMAGE=${{ steps.meta.outputs.base_image }}" \
              --build-arg "FRAMEWORK_VERSION=${{ steps.meta.outputs.framework_version }}" \
              --build-arg "VLLM_VERSION=${{ steps.meta.outputs.vllm_version }}" \
              --build-arg "VLLM_BUILD_VERSION=${{ steps.vllm_build_ver.outputs.vllm_build_version_full }}" \
              --build-arg "CRYPTOTENSORS_VERSION=${{ steps.crypto_version.outputs.ct_version_full }}" \
              --build-arg "BUILD_DATE=${{ steps.meta.outputs.build_date }}" \
              --label "io.vllm.version=${VLLM_VERSION}" \
              --label "io.vllm.build=${VLLM_BUILD_VERSION}" \
              --label "io.cryptotensors.version=${CT_VERSION}" \
              --label "org.opencontainers.image.version=${PRIMARY_TAG}" \
              --label "org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}" \
              --tag "${IMAGE_REF_GHCR}" \
              --provenance=false \
              --push \
              .
          fi
          
          echo "✓ Image built successfully"

      - name: Print build summary
        run: |
          DRYRUN="${{ steps.trigger.outputs.dryrun }}"
          if [ "$DRYRUN" = "true" ]; then
            echo "✓ Build Complete: vLLM OpenAI Image Built (DRY RUN - not pushed)"
          else
            echo "✓ Build Complete: vLLM OpenAI Image Built and Pushed to GHCR (per-arch)"
          fi
          echo "Image: ${{ steps.build.outputs.image_ref }}"
          echo "Platform: ${{ steps.meta.outputs.platform_os }}/${{ steps.meta.outputs.docker_arch }}"
          echo "vLLM Version: ${{ steps.meta.outputs.vllm_version }}"
          echo "vLLM-Build Version: ${{ steps.meta.outputs.vllm_build_version_full }}"
          echo "CryptoTensors Version: ${{ steps.meta.outputs.ct_version_full }}"
          echo "Framework Version: ${{ steps.meta.outputs.framework_version }}"

      - name: Aggressive cleanup after build
        if: ${{ steps.trigger.outputs.dryrun != 'true' }}
        run: |
          echo "=== Aggressive cleanup after build ==="
          
          # Keep reference to just-built image
          BUILT_IMAGE="${{ steps.build.outputs.image_ref }}"
          BASE_IMAGE="${{ steps.meta.outputs.base_image }}"
          
          # Remove base image (no longer needed)
          echo "Removing base image: ${BASE_IMAGE}"
          docker rmi "${BASE_IMAGE}" -f || true
          
          # Image pushed to registry, safe to remove local copy
          echo "Image pushed to registry, removing local copy to save space"
          docker rmi "${BUILT_IMAGE}" -f || true
          
          # Remove all dangling images
          docker image prune -f
          
          # Remove build cache
          docker builder prune -a -f
          
          # System-level cleanup
          docker system prune -a -f --volumes
          
          echo "=== Disk space after aggressive cleanup ==="
          df -h
          docker system df

  measure-baseline:
    name: Measure Baseline (${{ matrix.arch }})
    needs: [prepare, build-and-push]
    if: ${{ needs.build-and-push.outputs.dryrun != 'true' }}
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.prepare.outputs.matrix) }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Free disk space
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest

      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine image reference
        id: image_info
        run: |
          VLLM_VERSION='${{ needs.build-and-push.outputs.vllm_version }}'
          VLLM_BUILD_VERSION='${{ needs.build-and-push.outputs.vllm_build_version_full }}'
          CT_VERSION='${{ needs.build-and-push.outputs.ct_version_full }}'
          
          # Convert versions to PEP 440 format
          VLLM_VERSION_TAG=$(echo "$VLLM_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          VLLM_BUILD_VERSION_TAG=$(echo "$VLLM_BUILD_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          CT_VERSION_TAG=$(echo "$CT_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          
          PRIMARY_TAG="vllm-${VLLM_VERSION_TAG}_build-${VLLM_BUILD_VERSION_TAG}_crypto-${CT_VERSION_TAG}"
          
          # Determine architecture suffix
          ARCH="${{ matrix.arch }}"
          if [ "$ARCH" = "x86" ]; then
            ARCH_SUFFIX="amd64"
          else
            ARCH_SUFFIX="arm64"
          fi
          
          IMAGE_REF="${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}-${ARCH_SUFFIX}"
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"
          echo "Image to measure: ${IMAGE_REF}"

      - name: Aggressive cleanup before measurement
        run: |
          echo "=== Disk space before cleanup ==="
          df -h
          docker system df
          
          # Remove all containers
          docker container prune -f
          
          # Remove ALL images (buildx will pull fresh from GHCR)
          docker image prune -a -f
          docker rmi $(docker images -q) -f 2>/dev/null || true
          
          # Remove all buildx cache
          docker buildx prune -a -f
          
          # System-level cleanup
          docker system prune -a -f --volumes
          
          echo "=== Disk space after aggressive cleanup ==="
          df -h
          docker system df

      - name: Download hash-builder binary
        env:
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}
        run: |
          echo "Downloading hash-builder"
          
          # Map architecture to binary architecture
          ARCH="${{ matrix.arch }}"
          if [ "$ARCH" = "x86" ]; then
            BINARY_ARCH="x86_64"
            LIBC="gnu"
          elif [ "$ARCH" = "aarch64" ]; then
            BINARY_ARCH="aarch64"
            LIBC="musl"
          else
            echo "::error::Unsupported architecture: $ARCH"
            exit 1
          fi
          
          CT_VERSION_FULL="${{ needs.build-and-push.outputs.ct_version_full }}"
          HB_VERSION="${CT_VERSION_FULL#v}"
          HB_FILENAME="hash-builder-${HB_VERSION}-linux-${BINARY_ARCH}-${LIBC}"
          
          # Get cryptotensors tag
          BUILD_MODE="${{ needs.build-and-push.outputs.build_mode }}"
          if [ "$BUILD_MODE" = "rc" ]; then
            CT_TAG=$(gh release view --repo KoalaVault-ai/cryptotensors --json tagName -q .tagName)
          else
            CT_TAG=$(gh release list --repo KoalaVault-ai/cryptotensors --limit 50 | grep -v 'rc\.' | head -1 | awk '{print $1}')
          fi
          
          echo "Downloading hash-builder: $HB_FILENAME from $CT_TAG"
          gh release download "$CT_TAG" --repo KoalaVault-ai/cryptotensors --pattern "$HB_FILENAME"
          
          mv "$HB_FILENAME" hash-builder
          chmod +x hash-builder
          ls -lh hash-builder
          ./hash-builder --version || echo "Hash-builder ready"

      - name: Build measurement image and extract hash
        id: measure
        run: |
          set -euo pipefail
          
          IMAGE_REF="${{ steps.image_info.outputs.image_ref }}"
          echo "Building measurement image for: ${IMAGE_REF}"
          mkdir -p ./measurements
          
          echo "=== Disk space before measurement build ==="
          df -h
          docker system df
          
          # Build measurement image (buildx will pull from GHCR, already logged in)
          # After aggressive cleanup above, we have max space available
          docker buildx build \
            -f Dockerfile.measure \
            --build-arg BASE_IMAGE="${IMAGE_REF}" \
            --target export \
            --output type=local,dest=./measurements \
            --progress=plain \
            .
          
          echo "Measurement file extracted to ./measurements/"
          ls -la ./measurements/
          
          if [[ ! -f "./measurements/baseline_hash.txt" ]]; then
            echo "::error::baseline_hash.txt not found in measurements output"
            exit 1
          fi
          
          BASELINE_HASH="$(cat ./measurements/baseline_hash.txt | tr -d '\n')"
          if [[ -z "$BASELINE_HASH" ]]; then
            echo "::error::baseline_hash is empty in baseline_hash.txt"
            exit 1
          fi
          
          echo "baseline_hash=${BASELINE_HASH}" >> "$GITHUB_OUTPUT"
          echo "✓ Baseline hash extracted: ${BASELINE_HASH}"
          
          echo "=== Disk space after measurement ==="
          df -h

      - name: Cleanup after measurement
        run: |
          echo "=== Cleaning up after measurement ==="
          
          # Remove all images and build cache
          docker image prune -a -f
          docker buildx prune -a -f
          docker system prune -a -f --volumes
          
          echo "=== Disk space after cleanup ==="
          df -h
          docker system df

      - name: Build framework version string
        id: framework_info
        run: |
          VLLM_VERSION="${{ needs.build-and-push.outputs.vllm_version }}"
          VLLM_BUILD_VERSION="${{ needs.build-and-push.outputs.vllm_build_version_full }}"
          CT_VERSION="${{ needs.build-and-push.outputs.ct_version_full }}"
          ARCH="${{ matrix.arch }}"
          
          # Build framework version string matching the build job
          FRAMEWORK_VERSION="vllm-${VLLM_VERSION}-${ARCH}-cuda-linux-build-${VLLM_BUILD_VERSION}-cryptotensors-${CT_VERSION}"
          echo "framework_version=${FRAMEWORK_VERSION}" >> "$GITHUB_OUTPUT"
          
          BUILD_DATE=$(date -u +"%Y-%m-%d")
          echo "build_date=${BUILD_DATE}" >> "$GITHUB_OUTPUT"

      - name: Register baseline to API
        if: ${{ needs.build-and-push.outputs.register_baseline == 'true' && vars.KOALAVAULT_API_BASE_URL != '' }}
        run: |
          set -euo pipefail
          
          echo "[info] Registering baseline to API..."
          
          BASELINE_HASH="${{ steps.measure.outputs.baseline_hash }}"
          FRAMEWORK_VERSION="${{ steps.framework_info.outputs.framework_version }}"
          VLLM_VERSION="${{ needs.build-and-push.outputs.vllm_version }}"
          VLLM_BUILD_VERSION="${{ needs.build-and-push.outputs.vllm_build_version_full }}"
          CRYPTOTENSORS_VERSION="${{ needs.build-and-push.outputs.ct_version_full }}"
          BUILD_DATE="${{ steps.framework_info.outputs.build_date }}"
          
          # Build version.json as a JSON string for description field
          VERSION_JSON_STR=$(jq -n \
            --arg fw "$FRAMEWORK_VERSION" \
            --arg framework "vllm" \
            --arg vllm "$VLLM_VERSION" \
            --arg build "$VLLM_BUILD_VERSION" \
            --arg crypto "$CRYPTOTENSORS_VERSION" \
            --arg date "$BUILD_DATE" \
            '{
              framework_version: $fw,
              framework: $framework,
              vllm_version: $vllm,
              vllm_build_version: $build,
              cryptotensors_version: $crypto,
              build_date: $date
            }' | jq -c .)
          
          # Build baseline data with description as a string
          BASELINE_DATA=$(jq -n \
            --arg fw "$FRAMEWORK_VERSION" \
            --arg framework_type "vllm" \
            --arg hash "$BASELINE_HASH" \
            --arg desc "$VERSION_JSON_STR" \
            --arg tag "$VLLM_VERSION" \
            '{
              framework_version: $fw,
              framework_type: $framework_type,
              baseline_hash: $hash,
              description: $desc,
              tag: $tag
            }')
          
          echo "[info] Registering baseline: $FRAMEWORK_VERSION with hash: $BASELINE_HASH"
          echo "[debug] Baseline data:"
          echo "$BASELINE_DATA" | jq .
          
          echo "[info] Getting admin JWT token..."
          TOKEN_RESPONSE=$(curl -s -X POST "${{ vars.KOALAVAULT_API_BASE_URL }}/api/admin/api-key-login" \
            -H "Content-Type: application/json" \
            -d "{\"api_key\": \"${{ secrets.KOALAVAULT_ADMIN_API_KEY }}\"}")
          
          JWT_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.data.access_token')
          
          if [ "$JWT_TOKEN" = "null" ] || [ -z "$JWT_TOKEN" ]; then
            echo "::error::Failed to get JWT token"
            echo "$TOKEN_RESPONSE"
            exit 1
          fi
          
          echo "[info] JWT token obtained successfully"
          
          RESPONSE=$(curl -s -X POST "${{ vars.KOALAVAULT_API_BASE_URL }}/api/admin/framework/baselines" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$BASELINE_DATA")
          
          if echo "$RESPONSE" | jq -e '.success' > /dev/null; then
            BASELINE_ID=$(echo "$RESPONSE" | jq -r '.data.id')
            echo "[info] Baseline registered successfully with ID: $BASELINE_ID"
            echo "[info] Note: Baseline is registered but not activated. Please activate manually if needed."
          else
            echo "::error::Failed to register baseline"
            echo "$RESPONSE"
            exit 1
          fi

      - name: Print baseline summary
        run: |
          echo "=========================================="
          echo "Baseline Measurement Complete"
          echo "=========================================="
          echo "Framework Version: ${{ steps.framework_info.outputs.framework_version }}"
          echo "Baseline Hash: ${{ steps.measure.outputs.baseline_hash }}"
          echo "Image: ${{ steps.image_info.outputs.image_ref }}"
          echo "=========================================="

  create-manifests:
    name: Create Multi-Arch Manifests
    needs: [prepare, build-and-push]
    if: |
      needs.build-and-push.outputs.dryrun != 'true' && 
      needs.prepare.outputs.architecture_choice == 'both'
    runs-on: ubuntu-latest
    outputs:
      primary_tag: ${{ steps.create_manifest.outputs.primary_tag }}
    steps:
      - name: Login GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create multi-arch manifest for GHCR
        id: create_manifest
        run: |
          set -euo pipefail
          VLLM_VERSION='${{ needs.build-and-push.outputs.vllm_version }}'
          VLLM_BUILD_VERSION='${{ needs.build-and-push.outputs.vllm_build_version_full }}'
          CT_VERSION='${{ needs.build-and-push.outputs.ct_version_full }}'
          BUILD_MODE='${{ needs.build-and-push.outputs.build_mode }}'
          
          # Convert versions to PEP 440 format
          VLLM_VERSION_TAG=$(echo "$VLLM_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          VLLM_BUILD_VERSION_TAG=$(echo "$VLLM_BUILD_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          CT_VERSION_TAG=$(echo "$CT_VERSION" | sed 's/-rc\./-rc/g' | sed 's/-rc/rc/g')
          
          PRIMARY_TAG="vllm-${VLLM_VERSION_TAG}_build-${VLLM_BUILD_VERSION_TAG}_crypto-${CT_VERSION_TAG}"
          echo "primary_tag=$PRIMARY_TAG" >> "$GITHUB_OUTPUT"
          
          AMD_IMAGE="${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}-amd64"
          ARM_IMAGE="${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}-arm64"
          
          # Wait for both AMD64 and ARM64 images to be available
          echo "Waiting for both AMD64 and ARM64 images to be available..."
          MAX_RETRIES=30
          RETRY_DELAY=20
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Attempt $i/$MAX_RETRIES: Checking image availability..."
            
            AMD_EXISTS=false
            ARM_EXISTS=false
            
            if docker buildx imagetools inspect "${AMD_IMAGE}" > /dev/null 2>&1; then
              echo "✓ AMD64 image found: ${AMD_IMAGE}"
              AMD_EXISTS=true
            else
              echo "✗ AMD64 image not yet available: ${AMD_IMAGE}"
            fi
            
            if docker buildx imagetools inspect "${ARM_IMAGE}" > /dev/null 2>&1; then
              echo "✓ ARM64 image found: ${ARM_IMAGE}"
              ARM_EXISTS=true
            else
              echo "✗ ARM64 image not yet available: ${ARM_IMAGE}"
            fi
            
            if [ "$AMD_EXISTS" = true ] && [ "$ARM_EXISTS" = true ]; then
              echo "Both images are available!"
              break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Error: Timeout waiting for images to be available"
              exit 1
            fi
            
            echo "Waiting ${RETRY_DELAY} seconds before retry..."
            sleep $RETRY_DELAY
          done
          
          # Create multi-arch manifest combining amd64 and arm64
          echo "Creating GHCR manifest: ${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}"
          docker buildx imagetools create \
            --tag "${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}" \
            "${AMD_IMAGE}" \
            "${ARM_IMAGE}"
          
          echo "✓ Multi-arch manifest created for primary tag"
          
          # For official releases, also create user-friendly alias
          if [ "$BUILD_MODE" = "release" ]; then
            echo "Creating user-friendly alias: ${VLLM_VERSION}"
            docker buildx imagetools create \
              --tag "${{ env.GHCR_IMAGE_REPO }}:${VLLM_VERSION}" \
              "${{ env.GHCR_IMAGE_REPO }}:${PRIMARY_TAG}"
            echo "✓ User-friendly alias created"
          fi

  publish-dockerhub:
    name: Publish to Docker Hub (mirror GHCR digest)
    needs: [prepare, build-and-push, create-manifests]
    if: |
      needs.build-and-push.outputs.build_mode == 'release' && 
      needs.prepare.outputs.architecture_choice == 'both'
    runs-on: ubuntu-latest
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Mirror multi-arch manifest to Docker Hub
        run: |
          set -euo pipefail
          VLLM_VERSION='${{ needs.build-and-push.outputs.vllm_version }}'
          PRIMARY_TAG='${{ needs.create-manifests.outputs.primary_tag }}'
          
          SRC='${{ env.GHCR_IMAGE_REPO }}:'"${PRIMARY_TAG}"
          DST='${{ env.DOCKERHUB_IMAGE_REPO }}:'"${PRIMARY_TAG}"
          
          echo "Mirroring multi-arch manifest: ${SRC} -> ${DST}"
          if docker buildx imagetools inspect "${DST}" > /dev/null 2>&1; then
            echo "Tag exists on Docker Hub, skipping: ${DST}"
          else
            docker buildx imagetools create --tag "${DST}" "${SRC}"
            echo "✓ Primary tag mirrored to Docker Hub"
          fi
          
          # User-friendly alias on Docker Hub: vLLM version
          ALIAS='${{ env.DOCKERHUB_IMAGE_REPO }}:'"${VLLM_VERSION}"
          echo "Creating user-friendly alias: $ALIAS"
          docker buildx imagetools create --tag "$ALIAS" "$DST"
          echo "✓ User-friendly alias created on Docker Hub"
