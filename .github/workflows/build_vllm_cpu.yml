name: Build and Release vLLM CPU Container

on:
  workflow_dispatch:
    inputs:
      vllm_tag:
        description: "vLLM version tag (e.g., v0.9.2)"
        required: true
        type: string
      dryrun:
        description: "Dry run (build only, no push/register)"
        required: false
        default: false
        type: boolean
      register_baseline:
        description: "Register baseline to API (only if dryrun=false)"
        required: false
        default: false
        type: boolean
permissions:
  contents: read

env:
  VLLM_REPO: vllm-project/vllm
  DOCKER_IMAGE_NAME: vllm-cpu

jobs:
  build-and-measure:
    name: Build vLLM CPU (${{ matrix.arch }})
    runs-on: ubuntu-latest
    strategy:
      matrix:
        arch: [x86, aarch64]
    steps:
      - name: Free disk space
        uses: jlumbroso/free-disk-space@main
        with:
          tool-cache: true
          android: true
          dotnet: true
          haskell: true
          large-packages: true
          docker-images: true
          swap-storage: false
      
      - name: Checkout vllm-build repo (for packages)
        uses: actions/checkout@v4
        with:
          path: vllm-build
          fetch-depth: 0
          fetch-tags: true

      - name: Checkout vLLM repo
        uses: actions/checkout@v4
        with:
          repository: ${{ env.VLLM_REPO }}
          ref: ${{ github.event.inputs.vllm_tag }}
          path: vllm

      - name: Read vLLM-Build version
        id: vllm_build_ver
        working-directory: vllm-build
        run: |
          # Get version from git tag (fetch full history for accurate tagging)
          VLLM_BUILD_VERSION=$(git describe --tags --exact-match 2>/dev/null || git describe --tags --abbrev=0 2>/dev/null || echo "")
          if [ -z "$VLLM_BUILD_VERSION" ]; then
            echo "::warning::No git tag found. Using 'dev' as version."
            VLLM_BUILD_VERSION="dev"
          else
            echo "vLLM-Build version from git: $VLLM_BUILD_VERSION"
          fi
          echo "vllm_build_version=$VLLM_BUILD_VERSION" >> "$GITHUB_OUTPUT"

      - name: Download cryptotensors packages
        working-directory: vllm-build
        env:
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}
        run: |
          # Map architecture to wheel naming convention
          ARCH="${{ matrix.arch }}"
          if [ "$ARCH" = "x86" ]; then
            WHEEL_ARCH="x86_64"
          elif [ "$ARCH" = "aarch64" ]; then
            WHEEL_ARCH="aarch64"
          else
            WHEEL_ARCH="$ARCH"
          fi
          
          echo "Downloading packages for architecture: $WHEEL_ARCH"
          
          # Clean up any existing wheel files first
          rm -f *.whl 2>/dev/null || true
          
          # Download architecture-specific cryptotensors wheel only
          gh release download --repo koalavault/cryptotensors --pattern "*manylinux*${WHEEL_ARCH}.whl"
          
          # Download safetensors wheel (platform-independent)
          gh release download --repo koalavault/cryptotensors --pattern "safetensors-*.whl"
          
          # Verify required files exist
          if ! ls cryptotensors-*-manylinux_*_${WHEEL_ARCH}.whl 1> /dev/null 2>&1; then
            echo "::error::cryptotensors wheel for $WHEEL_ARCH not found"
            echo "Available files:"
            ls -la *.whl 2>/dev/null || echo "No wheel files found"
            exit 1
          fi
          
          if ! ls safetensors-*.whl 1> /dev/null 2>&1; then
            echo "::error::safetensors wheel not found"
            exit 1
          fi
          
          echo "Downloaded packages:"
          ls -lh *.whl

      - name: Extract CryptoTensors version
        id: crypto_version
        working-directory: vllm-build
        run: |
          # Extract version from cryptotensors wheel filename
          # e.g., cryptotensors-0.1.0-cp38-abi3-manylinux_2_28_x86_64.whl -> v0.1.0
          CRYPTO_WHL=$(ls cryptotensors-*-manylinux_*.whl | head -1)
          CRYPTO_VERSION=$(echo "$CRYPTO_WHL" | sed 's/cryptotensors-//' | sed 's/-cp.*//')
          CRYPTO_VERSION="v${CRYPTO_VERSION}"
          echo "cryptotensors_version=$CRYPTO_VERSION" >> "$GITHUB_OUTPUT"
          echo "CryptoTensors version: $CRYPTO_VERSION"
          echo "CryptoTensors wheel: $CRYPTO_WHL"

      - name: Copy packages to vLLM build directory
        run: |
          cp vllm-build/*.whl vllm/
          echo "Copied packages to vLLM directory:"
          ls -lh vllm/*.whl

      - name: Determine build metadata
        id: meta
        run: |
          set -euo pipefail
          
          VLLM_TAG="${{ github.event.inputs.vllm_tag }}"
          PLATFORM_OS="linux"
          ARCH="${{ matrix.arch }}"
          
          # Map architecture to Docker platform
          if [ "$ARCH" = "x86" ]; then
            DOCKER_ARCH="amd64"
          elif [ "$ARCH" = "aarch64" ]; then
            DOCKER_ARCH="arm64"
          else
            DOCKER_ARCH="$ARCH"
          fi
          
          echo "vllm_version=$VLLM_TAG" >> "$GITHUB_OUTPUT"
          echo "platform_os=$PLATFORM_OS" >> "$GITHUB_OUTPUT"
          echo "arch=$ARCH" >> "$GITHUB_OUTPUT"
          echo "docker_arch=$DOCKER_ARCH" >> "$GITHUB_OUTPUT"

          # Get CryptoTensors version
          CRYPTO_VERSION="${{ steps.crypto_version.outputs.cryptotensors_version }}"
          echo "cryptotensors_version=$CRYPTO_VERSION" >> "$GITHUB_OUTPUT"
          
          # Get vllm-build version
          VLLM_BUILD_VERSION="${{ steps.vllm_build_ver.outputs.vllm_build_version }}"
          echo "vllm_build_version=$VLLM_BUILD_VERSION" >> "$GITHUB_OUTPUT"

          # Build framework version: vllm-{version}-{arch}-cpu-{os}-build-{vllm-build-ver}-cryptotensors-{crypto-ver}
          FRAMEWORK_VERSION="vllm-${VLLM_TAG}-${ARCH}-cpu-${PLATFORM_OS}-build-${VLLM_BUILD_VERSION}-cryptotensors-${CRYPTO_VERSION}"
          echo "framework_version=$FRAMEWORK_VERSION" >> "$GITHUB_OUTPUT"

          # Get current build date (YYYY-MM-DD format)
          BUILD_DATE=$(date -u +"%Y-%m-%d")
          echo "build_date=$BUILD_DATE" >> "$GITHUB_OUTPUT"

          echo "=== Build Metadata ==="
          echo "Arch: $ARCH"
          echo "Docker Arch: $DOCKER_ARCH"
          echo "Platform: cpu"
          echo "OS: $PLATFORM_OS"
          echo "vLLM Version: $VLLM_TAG"
          echo "vLLM-Build Version: $VLLM_BUILD_VERSION"
          echo "CryptoTensors Version: $CRYPTO_VERSION"
          echo "Framework Version: $FRAMEWORK_VERSION"
          echo "Build Date: $BUILD_DATE"

      - uses: docker/setup-buildx-action@v3

      - name: Login Docker Hub
        if: ${{ github.event.inputs.dryrun != 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build vLLM CPU base image (Stage 1)
        id: build_base
        working-directory: vllm
        run: |
          set -euo pipefail
          PLATFORM="${{ steps.meta.outputs.platform_os }}/${{ steps.meta.outputs.docker_arch }}"
          BASE_IMAGE_REF="vllm-cpu-base:${{ steps.meta.outputs.vllm_version }}-${{ steps.meta.outputs.arch }}"
          ARCH="${{ steps.meta.outputs.arch }}"
          
          echo "base_image_ref=${BASE_IMAGE_REF}" >> "$GITHUB_OUTPUT"

          # Stage 1: Build pure vLLM CPU image from source (no cryptotensors yet)
          echo "[Stage 1] Building pure vLLM CPU from source: ${{ github.event.inputs.vllm_tag }}"
          echo "[Stage 1] Intermediate image: ${BASE_IMAGE_REF}"
          echo "[Stage 1] Platform: ${PLATFORM}"
          echo "[Stage 1] Architecture: ${ARCH}"
          
          docker buildx build \
            --builder default \
            --platform "${PLATFORM}" \
            --file docker/Dockerfile.cpu \
            --target vllm-openai \
            --tag "${BASE_IMAGE_REF}" \
            --provenance=false \
            --load \
            .
          
          echo "[Stage 1] âœ“ Base vLLM CPU image built successfully"

      - name: Build final image with CryptoTensors (Stage 2)
        id: build
        working-directory: vllm-build
        run: |
          set -euo pipefail
          TAG="${{ steps.meta.outputs.vllm_version }}"
          PLATFORM="${{ steps.meta.outputs.platform_os }}/${{ steps.meta.outputs.docker_arch }}"
          IMAGE_REF="${{ vars.DOCKERHUB_USERNAME }}/${{ env.DOCKER_IMAGE_NAME }}:${TAG}"
          BASE_IMAGE_REF="${{ steps.build_base.outputs.base_image_ref }}"
          DRYRUN="${{ github.event.inputs.dryrun }}"
          
          echo "image_ref=${IMAGE_REF}" >> "$GITHUB_OUTPUT"

          # Stage 2: Install CryptoTensors on top of base image
          echo "[Stage 2] Installing CryptoTensors on base image"
          echo "[Stage 2] Base image: ${BASE_IMAGE_REF}"
          echo "[Stage 2] Target image: ${IMAGE_REF}"
          echo "[Stage 2] Platform: ${PLATFORM}"
          
          # Use buildx with default builder to access local images from Stage 1
          if [ "$DRYRUN" = "true" ]; then
            echo "[Stage 2] Mode: DRY RUN (build only, no push)"
            docker buildx build \
              --builder default \
              --platform "${PLATFORM}" \
              --file Dockerfile \
              --build-arg "BASE_IMAGE=${BASE_IMAGE_REF}" \
              --build-arg "FRAMEWORK_VERSION=${{ steps.meta.outputs.framework_version }}" \
              --build-arg "VLLM_VERSION=${{ steps.meta.outputs.vllm_version }}" \
              --build-arg "VLLM_BUILD_VERSION=${{ steps.meta.outputs.vllm_build_version }}" \
              --build-arg "CRYPTOTENSORS_VERSION=${{ steps.meta.outputs.cryptotensors_version }}" \
              --build-arg "BUILD_DATE=${{ steps.meta.outputs.build_date }}" \
              --tag "${IMAGE_REF}" \
              --provenance=false \
              --load \
              .
          else
            echo "[Stage 2] Mode: RELEASE (build and push)"
            docker buildx build \
              --builder default \
              --platform "${PLATFORM}" \
              --file Dockerfile \
              --build-arg "BASE_IMAGE=${BASE_IMAGE_REF}" \
              --build-arg "FRAMEWORK_VERSION=${{ steps.meta.outputs.framework_version }}" \
              --build-arg "VLLM_VERSION=${{ steps.meta.outputs.vllm_version }}" \
              --build-arg "VLLM_BUILD_VERSION=${{ steps.meta.outputs.vllm_build_version }}" \
              --build-arg "CRYPTOTENSORS_VERSION=${{ steps.meta.outputs.cryptotensors_version }}" \
              --build-arg "BUILD_DATE=${{ steps.meta.outputs.build_date }}" \
              --tag "${IMAGE_REF}" \
              --provenance=false \
              --push \
              .
          fi
          
          echo "[Stage 2] âœ“ Final image with CryptoTensors built successfully"

      - name: Print build summary
        run: |
          DRYRUN="${{ github.event.inputs.dryrun }}"
          if [ "$DRYRUN" = "true" ]; then
            echo "âœ“ Build Complete: vLLM CPU Image Built (DRY RUN - not pushed)"
          else
            echo "âœ“ Build Complete: vLLM CPU Image Built and Pushed"
          fi
          echo "Image: ${{ steps.build.outputs.image_ref }}"
          echo "Framework Version: ${{ steps.meta.outputs.framework_version }}"

      - name: Download hash-builder
        working-directory: vllm-build
        env:
          GH_TOKEN: ${{ secrets.KOALAVAULT_TOKEN }}
        run: |
          echo "[Stage 2] Downloading hash-builder"
          
          # Clean up any existing hash-builder files
          rm -f hash-builder 2>/dev/null || true
          
          # Map architecture to binary naming convention
          ARCH="${{ matrix.arch }}"
          if [ "$ARCH" = "x86" ]; then
            BINARY_ARCH="x86_64"
          elif [ "$ARCH" = "aarch64" ]; then
            BINARY_ARCH="aarch64"
          else
            BINARY_ARCH="$ARCH"
          fi
          
          # Download hash-builder binary (with linux- prefix)
          gh release download --repo koalavault/cryptotensors --pattern "hash-builder-linux-${BINARY_ARCH}"
          
          # Rename and make executable
          mv hash-builder-linux-${BINARY_ARCH} hash-builder
          chmod +x hash-builder
          
          echo "Hash-builder downloaded:"
          ls -lh hash-builder
          ./hash-builder --version || echo "Hash-builder ready"

      - name: Build measurement image and extract hash (Stage 3)
        id: measure
        working-directory: vllm-build
        run: |
          set -euo pipefail
          
          echo "[Stage 3] Building measurement image and extracting baseline hash"
          echo "[Stage 3] Base image: ${{ steps.build.outputs.image_ref }}"
          mkdir -p ./measurements
          
          # Stage 3: Build measurement image using Dockerfile.measure with buildx for export
          # Note: Must use buildx for --output type=local
          docker buildx build \
            --builder default \
            -f Dockerfile.measure \
            --build-arg BASE_IMAGE="${{ steps.build.outputs.image_ref }}" \
            --target export \
            --output type=local,dest=./measurements \
            .
          
          echo "[Stage 3] Measurement file extracted to ./measurements/"
          ls -la ./measurements/
          
          # Read baseline hash from extracted file
          if [[ ! -f "./measurements/baseline_hash.txt" ]]; then
            echo "::error::baseline_hash.txt not found in measurements output"
            exit 1
          fi
          
          BASELINE_HASH="$(cat ./measurements/baseline_hash.txt | tr -d '\n')"
          if [[ -z "$BASELINE_HASH" ]]; then
            echo "::error::baseline_hash is empty in baseline_hash.txt"
            exit 1
          fi
          
          echo "baseline_hash=$BASELINE_HASH" >> "$GITHUB_OUTPUT"
          echo "[Stage 3] âœ“ Baseline hash extracted: $BASELINE_HASH"

      - name: Register baseline to API
        if: ${{ github.event.inputs.dryrun != 'true' && github.event.inputs.register_baseline == 'true' }}
        working-directory: vllm-build
        run: |
          set -euo pipefail
          echo "[info] Registering baseline to API..."
          
          FRAMEWORK_VERSION="${{ steps.meta.outputs.framework_version }}"
          BASELINE_HASH="${{ steps.measure.outputs.baseline_hash }}"
          VLLM_VERSION="${{ steps.meta.outputs.vllm_version }}"
          VLLM_BUILD_VERSION="${{ steps.meta.outputs.vllm_build_version }}"
          CRYPTOTENSORS_VERSION="${{ steps.meta.outputs.cryptotensors_version }}"
          BUILD_DATE="${{ steps.meta.outputs.build_date }}"
          
          # Build version.json as a JSON string for description field
          VERSION_JSON_STR=$(jq -n \
            --arg fw "$FRAMEWORK_VERSION" \
            --arg framework "vllm" \
            --arg vllm "$VLLM_VERSION" \
            --arg build "$VLLM_BUILD_VERSION" \
            --arg crypto "$CRYPTOTENSORS_VERSION" \
            --arg date "$BUILD_DATE" \
            '{
              framework_version: $fw,
              framework: $framework,
              vllm_version: $vllm,
              vllm_build_version: $build,
              cryptotensors_version: $crypto,
              build_date: $date
            }' | jq -c .)
          
          # Build baseline data with description as a string
          BASELINE_DATA=$(jq -n \
            --arg fw "$FRAMEWORK_VERSION" \
            --arg framework_type "vllm" \
            --arg hash "$BASELINE_HASH" \
            --arg desc "$VERSION_JSON_STR" \
            --arg tag "$VLLM_VERSION" \
            '{
              framework_version: $fw,
              framework_type: $framework_type,
              baseline_hash: $hash,
              description: $desc,
              tag: $tag
            }')
          
          echo "[info] Registering baseline: $FRAMEWORK_VERSION with hash: $BASELINE_HASH"
          echo "[debug] Baseline data:"
          echo "$BASELINE_DATA" | jq .
          
          echo "[info] Getting admin JWT token..."
          TOKEN_RESPONSE=$(curl -s -X POST "${{ vars.KOALAVAULT_API_BASE_URL }}/api/admin/api-key-login" \
            -H "Content-Type: application/json" \
            -d "{\"api_key\": \"${{ secrets.KOALAVAULT_ADMIN_API_KEY }}\"}")
          
          JWT_TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.data.access_token')
          
          if [ "$JWT_TOKEN" = "null" ] || [ -z "$JWT_TOKEN" ]; then
            echo "::error::Failed to get JWT token"
            echo "$TOKEN_RESPONSE"
            exit 1
          fi
          
          echo "[info] JWT token obtained successfully"
          
          RESPONSE=$(curl -s -X POST "${{ vars.KOALAVAULT_API_BASE_URL }}/api/admin/framework/baselines" \
            -H "Authorization: Bearer $JWT_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$BASELINE_DATA")
          
          if echo "$RESPONSE" | jq -e '.success' > /dev/null; then
            BASELINE_ID=$(echo "$RESPONSE" | jq -r '.data.id')
            echo "[info] Baseline registered successfully with ID: $BASELINE_ID"
            echo "[info] Note: Baseline is registered but not activated. Please activate manually if needed."
          else
            echo "::error::Failed to register baseline"
            echo "$RESPONSE"
            exit 1
          fi

      - name: Final summary
        run: |
          echo "=========================================="
          echo "Build and Measurement Complete"
          echo "=========================================="
          echo "vLLM Version: ${{ steps.meta.outputs.vllm_version }}"
          echo "Docker Image: ${{ steps.build.outputs.image_ref }}"
          echo "Framework Version: ${{ steps.meta.outputs.framework_version }}"
          echo "Baseline Hash: ${{ steps.measure.outputs.baseline_hash }}"
          echo "Build Date: ${{ steps.meta.outputs.build_date }}"
          echo "=========================================="
          if [ "${{ github.event.inputs.dryrun }}" = "true" ]; then
            echo "Mode: DRY RUN (image built but not pushed)"
          else
            echo "Mode: RELEASE (image pushed to Docker Hub)"
            if [ "${{ github.event.inputs.register_baseline }}" = "true" ]; then
              echo "Baseline: Registered to API"
            else
              echo "Baseline: Not registered (register_baseline=false)"
            fi
          fi

